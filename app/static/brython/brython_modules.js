__BRYTHON__.VFS_timestamp = 1647515395721
__BRYTHON__.use_VFS = true
var scripts = {"$timestamp": 1647515395721, "browser.local_storage": [".py", "\nimport sys\nfrom browser import window,console\n\nhas_local_storage=hasattr(window,'localStorage')\n\nclass _UnProvided():\n pass\n \nclass LocalStorage():\n storage_type=\"local_storage\"\n \n def __init__(self):\n  if not has_local_storage:\n   raise EnvironmentError(\"LocalStorage not available\")\n  self.store=window.localStorage\n  \n def __delitem__(self,key):\n  if (not isinstance(key,str)):\n   raise TypeError(\"key must be string\")\n  if key not in self:\n   raise KeyError(key)\n  self.store.removeItem(key)\n  \n def __getitem__(self,key):\n  if (not isinstance(key,str)):\n   raise TypeError(\"key must be string\")\n  res=self.store.getItem(key)\n  if res is not None :\n   return res\n  raise KeyError(key)\n  \n def __setitem__(self,key,value):\n  if not isinstance(key,str):\n   raise TypeError(\"key must be string\")\n  if not isinstance(value,str):\n   raise TypeError(\"value must be string\")\n  self.store.setItem(key,value)\n  \n  \n def __contains__(self,key):\n  if (not isinstance(key,str)):\n   raise TypeError(\"key must be string\")\n  res=self.store.getItem(key)\n  if res is None :\n   return False\n  return True\n  \n def __iter__(self):\n  keys=self.keys()\n  return keys.__iter__()\n  \n def get(self,key,default=None ):\n  if (not isinstance(key,str)):\n   raise TypeError(\"key must be string\")\n  return self.store.getItem(key)or default\n  \n def pop(self,key,default=_UnProvided()):\n  if (not isinstance(key,str)):\n   raise TypeError(\"key must be string\")\n  if type(default)is _UnProvided:\n   ret=self.get(key)\n   del self[key]\n   return ret\n  else :\n   if key in self:\n    ret=self.get(key)\n    del self[key]\n    return ret\n   else :\n    return default\n    \n    \n    \n def keys(self):\n  return [self.store.key(i)for i in range(self.store.length)]\n  \n def values(self):\n  return [self.__getitem__(k)for k in self.keys()]\n  \n def items(self):\n  return list(zip(self.keys(),self.values()))\n  \n def clear(self):\n  self.store.clear()\n  \n def __len__(self):\n  return self.store.length\n  \nif has_local_storage:\n storage=LocalStorage()\n", ["browser.window", "browser.console", "browser", "sys"]], "browser": [".py", "", [], 1], "browser.session_storage": [".py", "\nimport sys\nfrom browser import window\nfrom .local_storage import LocalStorage\n\nhas_session_storage=hasattr(window,'sessionStorage')\n\nclass SessionStorage(LocalStorage):\n\n storage_type=\"session_storage\"\n \n def __init__(self):\n  if not has_session_storage:\n   raise EnvironmentError(\"SessionStorage not available\")\n  self.store=window.sessionStorage\n  \nif has_session_storage:\n storage=SessionStorage()\n", ["browser.local_storage", "browser.local_storage.LocalStorage", "browser.window", "sys", "browser"]], "paginate": [".py", "from javascript import Math\n\n\nclass InvalidPage(Exception):\n    pass\n\n\nclass PageNotAnInteger(InvalidPage):\n    pass\n\n\nclass EmptyPage(InvalidPage):\n    pass\n\n\nclass Paginator:\n\n    def __init__(self, object_list, per_page, orphans=0,\n                 allow_empty_first_page=True):\n        self.object_list = object_list\n        self.per_page = int(per_page)\n        self.orphans = int(orphans)\n        self.allow_empty_first_page = allow_empty_first_page\n\n    def __iter__(self):\n        for page_number in self.page_range:\n            yield self.page(page_number)\n\n    def validate_number(self, number):\n        \"\"\"Validate the given 1-based page number.\"\"\"\n        try:\n            if isinstance(number, float) and not number.is_integer():\n                raise ValueError\n            number = int(number)\n        except (TypeError, ValueError):\n            raise PageNotAnInteger(_('That page number is not an integer'))\n        if number < 1:\n            raise EmptyPage('That page number is less than 1')\n        if number > self.num_pages:\n            if number == 1 and self.allow_empty_first_page:\n                pass\n            else:\n                raise EmptyPage('That page contains no results')\n        return number\n\n    def get_page(self, number):\n        \"\"\"\n        Return a valid page, even if the page argument isn't a number or isn't\n        in range.\n        \"\"\"\n        try:\n            number = self.validate_number(number)\n        except PageNotAnInteger:\n            number = 1\n        except EmptyPage:\n            number = self.num_pages\n        return self.page(number)\n\n    def page(self, number):\n        \"\"\"Return a Page object for the given 1-based page number.\"\"\"\n        number = self.validate_number(number)\n        bottom = (number - 1) * self.per_page\n        top = bottom + self.per_page\n        if top + self.orphans >= self.count:\n            top = self.count\n        return self._get_page(self.object_list[bottom:top], number, self)\n\n    def _get_page(self, *args, **kwargs):\n        \"\"\"\n        Return an instance of a single page.\n\n        This hook can be used by subclasses to use an alternative to the\n        standard :cls:`Page` object.\n        \"\"\"\n        return Page(*args, **kwargs)\n\n    @property\n    def count(self):\n        \"\"\"Return the total number of objects, across all pages.\"\"\"\n        # c = getattr(self.object_list, 'count', None)\n        # if callable(c) and not inspect.isbuiltin(c):\n        #     return c()\n        return len(self.object_list)\n\n    @property\n    def num_pages(self):\n        \"\"\"Return the total number of pages.\"\"\"\n        if self.count == 0 and not self.allow_empty_first_page:\n            return 0\n        hits = max(1, self.count - self.orphans)\n        return Math.ceil(hits / self.per_page)\n\n    @property\n    def page_range(self):\n        \"\"\"\n        Return a 1-based range of pages for iterating through within\n        a template for loop.\n        \"\"\"\n        return range(1, self.num_pages + 1)\n\n\nclass Page(): #collections.abc.Sequence\n\n    def __init__(self, object_list, number, paginator):\n        self.object_list = object_list\n        self.number = number\n        self.paginator = paginator\n\n    def __repr__(self):\n        return '<\u0421\u0442\u0440\u0430\u043d\u0438\u0446\u0430 %s \u0438\u0437 %s>' % (self.number, self.paginator.num_pages)\n\n    def __len__(self):\n        return len(self.object_list)\n\n    def __getitem__(self, index):\n        return self.object_list[index]\n\n    def has_next(self):\n        return self.number < self.paginator.num_pages\n\n    def has_previous(self):\n        return self.number > 1\n\n    def has_other_pages(self):\n        return self.has_previous() or self.has_next()\n\n    def next_page_number(self):\n        return self.paginator.validate_number(self.number + 1)\n\n    def previous_page_number(self):\n        return self.paginator.validate_number(self.number - 1)\n\n    def start_index(self):\n        \"\"\"\n        Return the 1-based index of the first object on this page,\n        relative to total objects in the paginator.\n        \"\"\"\n        # Special case, return zero if no items.\n        if self.paginator.count == 0:\n            return 0\n        return (self.paginator.per_page * (self.number - 1)) + 1\n\n    def end_index(self):\n        \"\"\"\n        Return the 1-based index of the last object on this page,\n        relative to total objects found (hits).\n        \"\"\"\n        # Special case for the last page because there can be orphans.\n        if self.number == self.paginator.num_pages:\n            return self.paginator.count\n        return self.number * self.paginator.per_page\n\n    def get_valid_range(self, max_range=7):\n\n        if self.paginator.num_pages <= max_range:\n            return self.paginator.page_range\n        else:\n            def_pos = Math.floor(max_range/2)\n            if self.number <= def_pos:\n                bot = 1\n                top = max_range + 1\n            else:\n                cur_pos = self.paginator.num_pages - self.number\n                pos = cur_pos if cur_pos < def_pos else def_pos\n                top = self.number + pos + 1\n                bot = top - max_range\n            return range(bot, top)", ["javascript.Math", "javascript"]], "_ajax": [".js", "// ajax\nvar $module = (function($B){\n\neval($B.InjectBuiltins())\nvar $N = $B.builtins.None,\n    _b_ = $B.builtins\n\nvar add_to_res = function(res, key, val) {\n    if(isinstance(val, list)){\n        for (j = 0; j < val.length; j++) {\n            add_to_res(res, key, val[j])\n        }\n    }else if (val instanceof File || val instanceof Blob){\n        res.append(key, val)\n    }else{res.append(key,str.$factory(val))}\n}\n\nfunction set_timeout(self, timeout){\n    if(timeout.seconds !== undefined){\n        self.js.$requestTimer = setTimeout(\n            function() {\n                self.js.abort()\n                if(timeout.func){\n                    timeout.func()\n                }\n            },\n            timeout.seconds * 1000)\n    }\n}\n\nfunction _read(req){\n    var xhr = req.js\n    if(xhr.responseType == \"json\"){\n        return $B.structuredclone2pyobj(xhr.response)\n    }\n    if(typeof xhr.response == \"string\"){\n        // on blocking mode, xhr.response is a string\n        var bytes = []\n        for(var i = 0, len = xhr.response.length; i < len; i++){\n            var cp = xhr.response.codePointAt(i)\n            if(cp > 0xf700){\n                bytes.push(cp - 0xf700)\n            }else{\n                bytes.push(cp)\n            }\n        }\n    }else{\n        // else it's an ArrayBuffer\n        var buf = new Uint8Array(xhr.response),\n            bytes = Array.from(buf.values())\n    }\n    var b = _b_.bytes.$factory(bytes)\n    if(req.mode == \"binary\"){\n        return b\n    }else if(req.mode == \"document\"){\n        return $B.JSObj.$factory(xhr.response)\n    }else{\n        var encoding = req.encoding || \"utf-8\"\n        return _b_.bytes.decode(b, encoding)\n    }\n}\n\nfunction handle_kwargs(self, kw, method){\n    var data,\n        encoding,\n        headers={},\n        cache,\n        mode = \"text\",\n        timeout = {}\n    for(var key in kw.$string_dict){\n        if(key == \"data\"){\n            var params = kw.$string_dict[key][0]\n            if(typeof params == \"string\"){\n                data = params\n            }else if(params.__class__ === _b_.dict){\n                for(var key in params.$numeric_dict){\n                    throw _b_.ValueError.$factory(\n                        'data only supports string keys, got ' + key)\n                }\n                params = params.$string_dict\n                var items = []\n                for(var key in params){\n                    items.push(encodeURIComponent(key) + \"=\" +\n                               encodeURIComponent(params[key][0]))\n                }\n                data = items.join(\"&\")\n            }else{\n                throw _b_.TypeError.$factory(\"wrong type for data: \" +\n                    $B.class_name(params))\n            }\n        }else if(key == \"encoding\"){\n            encoding = kw.$string_dict[key][0]\n        }else if(key == \"headers\"){\n            var value = kw.$string_dict[key][0]\n            if(! _b_.isinstance(value, _b_.dict)){\n                throw _b_.ValueError.$factory(\n                    \"headers must be a dict, not \" + $B.class_name(value))\n            }\n            for(key in value.$string_dict){\n                headers[key.toLowerCase()] = [key, value.$string_dict[key][0]]\n            }\n        }else if(key.startsWith(\"on\")){\n            var event = key.substr(2)\n            if(event == \"timeout\"){\n                timeout.func = kw.$string_dict[key][0]\n            }else{\n                var f = kw.$string_dict[key][0]\n                ajax.bind(self, event, f)\n            }\n        }else if(key == \"mode\"){\n            var mode = kw.$string_dict[key][0]\n        }else if(key == \"timeout\"){\n            timeout.seconds = kw.$string_dict[key][0]\n        }else if(key == \"cache\"){\n            cache = kw.$string_dict[key][0]\n        }\n    }\n    if(encoding && mode != \"text\"){\n        throw _b_.ValueError.$factory(\"encoding not supported for mode \" +\n            mode)\n    }\n    if((method == \"post\" || method == \"put\") && ! headers){\n        // For POST requests, set default header\n        self.js.setRequestHeader(\"Content-type\",\n                                 \"application/x-www-form-urlencoded\")\n    }\n    return {cache, data, encoding, headers, mode, timeout}\n}\n\nvar ajax = {\n    __class__: _b_.type,\n    __mro__: [_b_.object],\n\n    __repr__ : function(self){return '<object Ajax>'},\n    __str__ : function(self){return '<object Ajax>'},\n\n    $infos: {\n        __module__: \"builtins\",\n        __name__: \"ajax\"\n    },\n\n    __getattribute__: function(self, attr){\n        if(ajax[attr] !== undefined){\n            return function(){\n                return ajax[attr].call(null, self, ...arguments)\n            }\n        }else if(attr == \"text\"){\n            return _read(self)\n        }else if(attr == \"json\"){\n            if(self.js.responseType == \"json\"){\n                return _read(self)\n            }else{\n                var resp = _read(self)\n                try{\n                    return $B.structuredclone2pyobj(JSON.parse(resp))\n                }catch(err){\n                    console.log('attr json, invalid resp', resp)\n                    throw err\n                }\n            }\n        }else if(self.js[attr] !== undefined){\n            if(typeof self.js[attr] == \"function\"){\n                return function(){\n                    if(attr == \"setRequestHeader\"){\n                        ajax.set_header.call(null, self, ...arguments)\n                    }else{\n                        if(attr == 'overrideMimeType'){\n                            console.log('override mime type')\n                            self.hasMimeType = true\n                        }\n                        return self.js[attr](...arguments)\n                    }\n                }\n            }else{\n                return self.js[attr]\n            }\n        }else if(attr == \"xml\"){\n            return $B.JSObj.$factory(self.js.responseXML)\n        }\n    },\n\n    bind: function(self, evt, func){\n        // req.bind(evt,func) is the same as req.onevt = func\n        self.js['on' + evt] = function(){\n            try{\n                return func.apply(null, arguments)\n            }catch(err){\n                $B.handle_error(err)\n            }\n        }\n        return _b_.None\n    },\n\n    open: function(){\n        var $ = $B.args('open', 4,\n                {self: null, method: null, url: null, async: null},\n                ['self', 'method', 'url', 'async'], arguments,\n                {async: true}, null, null),\n            self = $.self,\n            method = $.method,\n            url = $.url,\n            async = $.async\n        self.$method = method\n        self.blocking = ! self.async\n        self.js.open(method, url, async)\n    },\n\n    read: function(self){\n        return _read(self)\n    },\n\n    send: function(self, params){\n        // params can be Python dictionary or string\n        var content_type\n        for(var key in self.headers){\n            var header = self.headers[key]\n            self.js.setRequestHeader(header[0], header[1])\n            if(key == 'content-type'){\n                content_type = header[1]\n            }\n        }\n        if((self.encoding || self.blocking) && ! self.hasMimeType){\n            // On blocking mode, or if an encoding has been specified,\n            // override Mime type so that bytes are not processed\n            // (unless the Mime type has been explicitely set)\n            self.js.overrideMimeType('text/plain;charset=x-user-defined')\n        }\n        var res = ''\n        if(! params){\n            self.js.send()\n            return _b_.None\n        }\n        if(isinstance(params, str)){\n            res = params\n        }else if(isinstance(params, dict)){\n            if(content_type == 'multipart/form-data'){\n                // The FormData object serializes the data in the 'multipart/form-data'\n                // content-type so we may as well override that header if it was set\n                // by the user.\n                res = new FormData()\n                var items = _b_.list.$factory(_b_.dict.items(params))\n                for(var i = 0, len = items.length; i < len; i++){\n                    add_to_res(res, str.$factory(items[i][0]), items[i][1])\n                }\n            }else{\n                if(self.$method && self.$method.toUpperCase() == \"POST\" &&\n                        ! content_type){\n                    // Set default Content-Type for POST requests\n                    self.js.setRequestHeader(\"Content-Type\",\n                        \"application/x-www-form-urlencoded\")\n                }\n                var items = _b_.list.$factory(_b_.dict.items(params))\n                for(var i = 0, len = items.length; i < len; i++){\n                    var key = encodeURIComponent(str.$factory(items[i][0]));\n                    if(isinstance(items[i][1], list)){\n                        for (j = 0; j < items[i][1].length; j++) {\n                            res += key +'=' +\n                                encodeURIComponent(str.$factory(items[i][1][j])) + '&'\n                        }\n                    }else{\n                        res += key + '=' +\n                            encodeURIComponent(str.$factory(items[i][1])) + '&'\n                    }\n                }\n                res = res.substr(0, res.length - 1)\n            }\n        }else{\n            throw _b_.TypeError.$factory(\n                \"send() argument must be string or dictionary, not '\" +\n                str.$factory(params.__class__) + \"'\")\n        }\n        self.js.send(res)\n        return _b_.None\n    },\n\n    set_header: function(self, key, value){\n        self.headers[key.toLowerCase()] = [key, value]\n    },\n\n    set_timeout: function(self, seconds, func){\n        self.js.$requestTimer = setTimeout(\n            function() {\n                self.js.abort()\n                func()\n            },\n            seconds * 1000)\n    }\n\n}\n\najax.$factory = function(){\n\n    if(window.XMLHttpRequest){// code for IE7+, Firefox, Chrome, Opera, Safari\n        var xmlhttp = new XMLHttpRequest()\n    }else{// code for IE6, IE5\n        var xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\")\n    }\n    xmlhttp.onreadystatechange = function(){\n        // here, \"this\" refers to xmlhttp\n        var state = this.readyState\n        if(this.responseType == \"\" || this.responseType == \"text\"){\n            res.js.text = this.responseText\n        }\n        var timer = this.$requestTimer\n        if(state == 0 && this.onuninitialized){\n            this.onuninitialized(res)\n        }else if(state == 1 && this.onloading){\n            this.onloading(res)\n        }else if(state == 2 && this.onloaded){\n            this.onloaded(res)\n        }else if(state == 3 && this.oninteractive){\n            this.oninteractive(res)\n        }else if(state == 4 && this.oncomplete){\n            if(timer !== null){\n                window.clearTimeout(timer)\n            }\n            this.oncomplete(res)\n        }\n    }\n    var res = {\n        __class__: ajax,\n        js: xmlhttp,\n        headers: {}\n    }\n    return res\n}\n\nfunction _request_without_body(method){\n    var $ = $B.args(method, 3, {method: null, url: null, blocking: null},\n        [\"method\", \"url\", \"blocking\"], arguments, {blocking: false},\n        null, \"kw\"),\n    method = $.method,\n    url = $.url,\n    async = !$.blocking,\n    kw = $.kw\n    var self = ajax.$factory()\n    self.blocking = $.blocking\n    var items = handle_kwargs(self, kw, method),\n        mode = self.mode = items.mode,\n        encoding = self.encoding = items.encoding\n        qs = items.data,\n        timeout = items.timeout\n    set_timeout(self, timeout)\n    if(qs){\n        url += \"?\" + qs\n    }\n    if(! (items.cache === true)){\n        url += (qs ? \"&\" : \"?\") + (new Date()).getTime()\n    }\n    self.js.open(method.toUpperCase(), url, async)\n\n    if(async){\n        if(mode == \"json\" || mode == \"document\"){\n            self.js.responseType = mode\n        }else{\n            self.js.responseType = \"arraybuffer\"\n            if(mode != \"text\" && mode != \"binary\"){\n                throw _b_.ValueError.$factory(\"invalid mode: \" + mode)\n            }\n        }\n    }else{\n        self.js.overrideMimeType('text/plain;charset=x-user-defined')\n    }\n    for(var key in items.headers){\n        var header = items.headers[key]\n        self.js.setRequestHeader(header[0], header[1])\n    }\n    // Add function read() to return str or bytes according to mode\n    self.js.send()\n}\n\nfunction _request_with_body(method){\n    var $ = $B.args(method, 3, {method: null, url: null, blocking: null},\n        [\"method\", \"url\", \"blocking\"], arguments, {blocking: false},\n        null, \"kw\"),\n        method = $.method,\n        url = $.url,\n        async = !$.blocking,\n        kw = $.kw,\n        content_type\n\n    var self = ajax.$factory()\n    self.js.open(method.toUpperCase(), url, async)\n    var items = handle_kwargs(self, kw, method),\n        data = items.data,\n        timeout = items.timeout\n    set_timeout(self, timeout)\n    for(var key in items.headers){\n        var header = items.headers[key]\n        self.js.setRequestHeader(header[0], header[1])\n        if(key == 'content-type'){\n            content_type = header[1]\n        }\n    }\n    if(method.toUpperCase() == 'POST' && !content_type){\n        // set default Content-Type for POST requests\n        self.js.setRequestHeader('Content-Type',\n            'application/x-www-form-urlencoded')\n    }\n\n    // Add function read() to return str or bytes according to mode\n    self.js.read = function(){\n        return _read(self)\n    }\n    self.js.send(data)\n}\n\nfunction connect(){\n    _request_without_body.call(null, \"connect\", ...arguments)\n}\n\nfunction _delete(){\n    _request_without_body.call(null, \"delete\", ...arguments)\n}\n\nfunction get(){\n    _request_without_body.call(null, \"get\", ...arguments)\n}\n\nfunction head(){\n    _request_without_body.call(null, \"head\", ...arguments)\n}\n\nfunction options(){\n    _request_without_body.call(null, \"options\", ...arguments)\n}\n\nfunction patch(){\n    _request_with_body.call(null, \"put\", ...arguments)\n}\n\nfunction post(){\n    _request_with_body.call(null, \"post\", ...arguments)\n}\n\nfunction put(){\n    _request_with_body.call(null, \"put\", ...arguments)\n}\n\nfunction trace(){\n    _request_without_body.call(null, \"trace\", ...arguments)\n}\n\nfunction file_upload(){\n    // ajax.file_upload(url, file, method=\"POST\", **callbacks)\n    var $ = $B.args(\"file_upload\", 2, {url: null, \"file\": file},\n            [\"url\", \"file\"], arguments, {}, null, \"kw\"),\n        url = $.url,\n        file = $.file,\n        kw = $.kw\n\n    var self = ajax.$factory(),\n        method = 'POST',\n        field_name = 'filetosave'\n\n    if(kw.$string_dict.method !== undefined){\n        method = kw.$string_dict.method[0]\n    }\n\n    if(kw.$string_dict.field_name !== undefined){\n        field_name = kw.$string_dict.field_name[0]\n    }\n\n    var formdata = new FormData()\n    formdata.append(field_name, file, file.name)\n\n    self.js.open(method, url, True)\n    self.js.send(formdata)\n\n    for(key in kw.$string_dict){\n        if(key.startsWith(\"on\")){\n            ajax.bind(self, key.substr(2), kw.$string_dict[key][0])\n        }\n    }\n}\n\n$B.set_func_names(ajax)\n\nreturn {\n    ajax: ajax,\n    Ajax: ajax,\n    $$delete: _delete,\n    file_upload: file_upload,\n    connect,\n    get,\n    head,\n    options,\n    patch,\n    post,\n    put,\n    trace\n}\n\n})(__BRYTHON__)\n"], "browser.timer": [".py", "from browser import console,window\n\ndef wrap(func,*args):\n\n\n def f():\n  try :\n   return func(*args)\n  except Exception as exc:\n   msg=''\n   try :\n    if exc.args:\n     msg='{0.info}\\n{0.__class__.__name__}: {0.args[0]}'.format(exc)\n    else :\n     msg=str(exc)\n    import sys\n    sys.stderr.write(msg)\n   except Exception as exc2:\n    console.log(\"Error printing exception traceback\",exc2,func,\n    args,kw)\n return f\n \nclear_interval=window.clearInterval\n\nclear_timeout=window.clearTimeout\n\ndef set_interval(func,interval,*args):\n return window.setInterval(wrap(func,*args),interval)\n \ndef set_timeout(func,interval,*args):\n return int(window.setTimeout(wrap(func,*args),interval))\n \ndef request_animation_frame(func):\n return int(window.requestAnimationFrame(func))\n \ndef cancel_animation_frame(int_id):\n window.cancelAnimationFrame(int_id)\n \ndef set_loop_timeout(x):\n\n assert isinstance(x,int)\n __BRYTHON__.loop_timeout=x\n", ["browser.window", "browser.console", "browser", "sys"]], "_aio": [".js", "// Replacement for asyncio.\n//\n// CPython asyncio can't be implemented for Brython because it relies on\n// blocking function (eg run(), run_until_complete()), and such functions\n// can't be defined in Javascript. It also manages an event loop, and a\n// browser only has its own built-in event loop.\n//\n// This module exposes functions whose result can be \"await\"-ed inside\n// asynchrounous functions defined by \"async def\".\n\nvar $module = (function($B){\n\nvar _b_ = $B.builtins\n\nvar responseType = {\n    \"text\": \"text\",\n    \"binary\": \"arraybuffer\",\n    \"dataURL\": \"arraybuffer\"\n}\n\nfunction handle_kwargs(kw, method){\n    var data,\n        cache = false,\n        format = \"text\",\n        headers = {},\n        timeout = {}\n    for(var key in kw.$string_dict){\n        if(key == \"data\"){\n            var params = kw.$string_dict[key][0]\n            if(typeof params == \"string\"){\n                data = params\n            }else if(_b_.isinstance(params, _b_.bytes)){\n                data = new ArrayBuffer(params.source.length)\n                var array = new Int8Array(data)\n                for(var i = 0, len = params.source.length; i < len; i++){\n                    array[i] = params.source[i]\n                }\n            }else{\n                if(params.__class__ !== _b_.dict){\n                    throw _b_.TypeError.$factory(\"wrong type for data, \" +\n                        \"expected dict, bytes or str, got \" +\n                        $B.class_name(params))\n                }\n                params = params.$string_dict\n                var items = []\n                for(var key in params){\n                    items.push(encodeURIComponent(key) + \"=\" +\n                               encodeURIComponent(params[key][0]))\n                }\n                data = items.join(\"&\")\n            }\n        }else if(key == \"headers\"){\n            headers = _b_.dict.$to_obj(kw.$string_dict[key][0])\n        }else if(key.startsWith(\"on\")){\n            var event = key.substr(2)\n            if(event == \"timeout\"){\n                timeout.func = kw.$string_dict[key][0]\n            }else{\n                ajax.bind(self, event, kw.$string_dict[key][0])\n            }\n        }else if(key == \"timeout\"){\n            timeout.seconds = kw.$string_dict[key][0]\n        }else if(key == \"cache\"){\n            cache = kw.$string_dict[key][0]\n        }else if(key == \"format\"){\n            format = kw.$string_dict[key][0]\n        }\n    }\n    if(method == \"post\"){\n        // For POST requests, set default header\n        if(! headers.hasOwnProperty(\"Content-type\")){\n            headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\"\n        }\n    }\n    return {\n        body: data,\n        cache: cache,\n        format: format,\n        timeout: timeout,\n        headers: headers\n    }\n}\n\nfunction ajax(){\n    var $ = $B.args(\"ajax\", 2, {method: null, url: null},\n            [\"method\", \"url\"], arguments, {},\n            null, \"kw\"),\n        method = $.method.toUpperCase(),\n        url = $.url,\n        kw = $.kw\n    var args = handle_kwargs(kw, \"get\")\n    if(method == \"GET\" && ! args.cache){\n        url = url + \"?ts\" + (new Date()).getTime() + \"=0\"\n    }\n    if(args.body && method == \"GET\"){\n        url = url + (args.cache ? \"?\" : \"&\") + args.body\n    }\n    var func = function(){\n        return new Promise(function(resolve, reject){\n            var xhr = new XMLHttpRequest()\n            xhr.open(method, url, true)\n            for(key in args.headers){\n                xhr.setRequestHeader(key, args.headers[key])\n            }\n            xhr.format = args.format\n            xhr.responseType = responseType[args.format]\n            xhr.onreadystatechange = function(){\n                if(this.readyState == 4){\n                    this.__class__ = HTTPRequest\n                    resolve(this)\n                }\n            }\n            if(args.body &&\n                    ['POST', 'PUT', 'DELETE', 'PATCH'].indexOf(method) > -1){\n                xhr.send(args.body)\n            }else{\n                xhr.send()\n            }\n        })\n    }\n    func.$infos = {\n        __name__: \"ajax_\" + method\n    }\n    return {\n        __class__: $B.coroutine,\n        $args: [url, args],\n        $func: func\n    }\n}\n\nfunction event(){\n    // event(element, *names) is a Promise on the events \"names\" happening on\n    // the element. This promise always resolves (never rejects) with the\n    // first triggered DOM event.\n    var $ = $B.args(\"event\", 1, {element: null},\n            [\"element\"], arguments, {}, \"names\", null),\n        element = $.element,\n        names = $.names\n    return new Promise(function(resolve){\n        var callbacks = []\n        names.forEach(function(name){\n            var callback = function(evt){\n                // When one of the handled events is triggered, all bindings\n                // are removed\n                callbacks.forEach(function(items){\n                    $B.DOMNode.unbind(element, items[0], items[1])\n                })\n                resolve($B.$DOMEvent(evt))\n            }\n            callbacks.push([name, callback])\n            $B.DOMNode.bind(element, name, callback)\n        })\n    })\n}\n\nvar HTTPRequest = $B.make_class(\"Request\")\n\nHTTPRequest.data = _b_.property.$factory(function(self){\n    if(self.format == \"binary\"){\n        var view = new Uint8Array(self.response)\n        return _b_.bytes.$factory(Array.from(view))\n    }else if(self.format == \"text\"){\n        return self.responseText\n    }else if(self.format == \"dataURL\"){\n        var base64String = btoa(String.fromCharCode.apply(null,\n            new Uint8Array(self.response)))\n        return \"data:\" + self.getResponseHeader(\"Content-Type\") +\n            \";base64,\" + base64String\n    }\n})\n\nHTTPRequest.response_headers = _b_.property.$factory(function(self){\n    var headers = self.getAllResponseHeaders()\n    if(headers === null){return _b_.None}\n    var res = $B.empty_dict()\n    if(headers.length > 0){\n        // Convert the header string into an array\n        // of individual headers\n        var lines = headers.trim().split(/[\\r\\n]+/)\n        // Create a map of header names to values\n        lines.forEach(function(line){\n          var parts = line.split(': ')\n          var header = parts.shift()\n          var value = parts.join(': ')\n          _b_.dict.$setitem(res, header, value)\n        })\n    }\n    return res\n})\n\nfunction get(){\n    return ajax.bind(null, \"GET\").apply(null, arguments)\n}\n\nfunction iscoroutine(f){\n    return f.__class__ === $B.coroutine\n}\n\nfunction iscoroutinefunction(f){\n    return (f.$infos.__code__.co_flags & 128) != 0\n}\n\nfunction post(){\n    return ajax.bind(null, \"POST\").apply(null, arguments)\n}\n\nfunction run(coro){\n    var handle_success = function(){\n            $B.leave_frame()\n        },\n        handle_error = function(err){\n            // coro.$stack is a snapshot of the frames stack when the async\n            // function was called. Restore it to get the correct call tree\n            err.$stack = coro.$stack.concat([$B.last(err.$stack)])\n            $B.handle_error(err)\n        }\n\n    var $ = $B.args(\"run\", 3, {coro: null, onsuccess: null, onerror: null},\n            [\"coro\", \"onsuccess\", \"onerror\"], arguments,\n            {onsuccess: handle_success, onerror: handle_error},\n            null, null),\n        coro = $.coro,\n        onsuccess = $.onsuccess,\n        onerror = $.onerror\n\n    if(onerror !== handle_error){\n        function error_func(exc){\n            try{\n                onerror(exc)\n            }catch(err){\n                handle_error(err)\n            }\n        }\n    }else{\n        error_func = handle_error\n    }\n    var save_stack = $B.frames_stack.slice()\n    $B.coroutine.send(coro).then(onsuccess).catch(error_func)\n    $B.frames_stack = save_stack\n    return _b_.None\n}\n\nfunction sleep(seconds){\n    var func = function(){\n        return new Promise(resolve => setTimeout(\n            function(){resolve(_b_.None)}, 1000 * seconds))\n    }\n    func.$infos = {\n        __name__: \"sleep\"\n    }\n    return {\n        __class__: $B.coroutine,\n        $args: [seconds],\n        $func: func\n    }\n}\n\nreturn {\n    ajax: ajax,\n    event: event,\n    get: get,\n    iscoroutine: iscoroutine,\n    iscoroutinefunction: iscoroutinefunction,\n    post: post,\n    run: run,\n    sleep: sleep\n}\n\n})(__BRYTHON__)\n"], "browser.html": [".py", "from _html import *\n", ["_html"]], "browser.ajax": [".py", "from _ajax import *\n", ["_ajax"]], "custom_table": [".py", "from javascript import Math, Date\nfrom browser import document, html, window, aio\n#from browser.aio import run #, async, await\nfrom paginate import *\n\n\nclass BrythonTable():\n    \n    btn_class = 'btn btn-outline-secondary btn-sm'\n    btn_class_active = 'btn btn-secondary btn-sm'\n    orphans = 3\n    _not = ['no', 'false',  '\u043d\u0435\u0442', '\u043d', 'n', ]\n    use_paginate = True\n\n    def __init__(self, target, page=1):\n        self.target = target\n        try:\n            self.per_page = self.target.attrs['data-perpage']\n        except KeyError:\n            self.per_page = 20\n        try:\n            self.use_paginate = self.target.attrs['data-paginate']\n            if self.use_paginate.lower() in self._not:\n                self.use_paginate=False\n        except KeyError:\n            pass\n        \n\n        self._initUIComponent()\n        self._register_events()\n        self.model = [row for row in self.target.select('tbody tr')]\n        if not self.use_paginate:\n            self.per_page = len(self.model)\n        self.paginator = Paginator(self.model, self.per_page, orphans=self.orphans)\n        self.get_page(page)\n        self._render()\n\n    def _initUIComponent(self):\n        \n        self.search = html.INPUT(\n            Class='form-control form-control-sm', \n            type='search', \n            **{'placeholder': '\u041f\u043e\u0438\u0441\u043a', 'aria-label': '\u041f\u043e\u0438\u0441\u043a'}\n        )\n        self.bot_div = html.DIV(Class=\"btn-toolbar\", id=\"divPaginate\")\n        self.raquo = html.SPAN(\"&raquo\", **{'aria-hidden': 'true'})\n        self.laquo = html.SPAN(\"&laquo\", **{'aria-hidden': 'true'})\n        self.btn_first = html.BUTTON(\n            self.laquo.html*2,\n            type=\"button\",\n            Class=self.btn_class,\n            **{'aria-label': 'PrePrevious',\n            'data-id': 'first'}\n        )\n        self.btn_prev = html.BUTTON(\n            self.laquo.html,\n            type=\"button\",\n            Class=self.btn_class,\n            **{'aria-label': 'Previous',\n            'data-id': 'prev'}\n        )\n        self.btn_next = html.BUTTON(\n            self.raquo.html,\n            type=\"button\",\n            Class=self.btn_class,\n            **{'aria-label': 'Next',\n            'data-id': 'next'}\n        )\n        self.btn_last = html.BUTTON(\n            self.raquo.html*2,\n            type=\"button\",\n            Class=self.btn_class,\n            **{'aria-label': 'NextNext',\n            'data-id': 'last'}\n        )\n        self.btn_cur = html.BUTTON(\n            type=\"button\",\n            Class=self.btn_class,\n            **{'aria-label': 'Current'}\n        )\n        self.select_per_page = html.SELECT(html.OPTION(elt, value=i) \n            for i, elt in enumerate([10, 20, 50, 100]))\n        #self.select_per_page.Class = 'form-control form-control-sm form-select'\n        self.select_per_page.classList.add(\"form-control\")\n        self.select_per_page.classList.add(\"form-control-sm\")\n        for item in self.select_per_page.options:\n            if item.text == str(self.per_page):\n                item.selected = True\n\n    def _register_events(self):\n        self.btn_next.bind('click', self._click_btn_page)\n        self.btn_last.bind('click', self._click_btn_page)\n        self.btn_prev.bind('click', self._click_btn_page)\n        self.btn_first.bind('click', self._click_btn_page)\n        self.search.bind('input', self.filter_data)\n        self.select_per_page.bind('change', self.update_per_page)\n\n    def _render_paginate_group(self):\n        if self.use_paginate:\n            self.bot_div.clear()\n            \n            if self.page.has_previous():\n                self.btn_first.disabled = False\n                self.btn_prev.disabled = False\n            else:\n                self.btn_first.disabled = True\n                self.btn_prev.disabled = True\n            if self.page.has_next():\n                self.btn_next.disabled = False\n                self.btn_last.disabled = False\n            else:\n                self.btn_next.disabled = True\n                self.btn_last.disabled = True\n            \n            div_number = html.DIV(Class=\"btn-group\")\n            for page in self.page.get_valid_range():\n                if page == self.page.number:\n                    btn = html.BUTTON(page, type=\"button\",\n                        Class=self.btn_class_active, id=\"currentPage\",\n                        **{'data-id': page, 'data-active': True}\n                        )\n                    btn.disabled = True\n                else:\n                    btn = html.BUTTON(page, type=\"button\",\n                        Class=self.btn_class,\n                        **{'data-id': page}\n                        )\n                \n                btn.bind('click', self._click_btn_page)\n                div_number <= btn\n            # badge = f'<span class=\"badge badge-pill badge-light\">{self.paginator.num_pages}</span>'\n            #badge = html.SPAN(self.paginator.num_pages, Class='badge')\n            self.bot_div <= self.btn_first\n            self.bot_div <= self.btn_prev\n            self.bot_div <= div_number\n            self.bot_div <= self.btn_next\n            self.btn_last.clear()\n            self.btn_last <= self.raquo.html\n            self.btn_last <= \" \" + str(self.paginator.num_pages)\n            self.bot_div <= self.btn_last\n\n    def _click_btn_page(self, event):\n        target = event.target\n        try:\n            btn = target.closest(\"BUTTON\")\n            btn_id = btn.attrs[\"data-id\"]\n        except KeyError:\n            btn_id = \"first\"\n        \n        try:\n            btn_id_int = int(btn_id)\n            self.get_page(btn_id_int)\n        except ValueError:\n            if btn_id == \"next\":\n                self.get_page(self.page.next_page_number())\n            elif btn_id == \"prev\":\n                self.get_page(self.page.previous_page_number())\n            elif btn_id == \"first\":\n                self.get_page(1)\n            elif btn_id == \"last\":\n                self.get_page(self.paginator.num_pages)\n        self._render_paginate_group()\n    \n    def _render(self):\n\n        for idx, item in enumerate(self.target.select('thead th')):\n            link_up = html.A(\"&#11165\", href=\"#\",\n                Class=\"badge badge-light badge-secondary\",\n                **{'data-ascending': 'up', 'title': '\u043f\u043e \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044e', 'data-idx': idx})\n            link_up.bind('click', self.sorted_data)\n            link_down = html.A(\"&#11167\", href=\"#\", Class=\"badge badge-light badge-secondary\", **{'data-ascending': 'down', 'title': '\u043f\u043e \u0443\u0431\u044b\u0432\u0430\u043d\u0438\u044e', 'data-idx': idx})\n            link_down.bind('click', self.sorted_data)\n            item <= link_up + link_down\n        \n        count_col = len(self.target.select('thead th'))\n        tr = self.target.select_one('thead')\n        top_div = html.DIV()#Class=\"row\"\n        inner_top_div = html.DIV(Class=\"row\")\n        if self.use_paginate:\n            inner_top_div <= html.DIV(self.select_per_page, Class=\"col-sm-3\")\n        inner_top_div <= html.DIV(self.search, Class=\"col-sm mr-auto\")\n        top_div <= inner_top_div\n        tr.prepend(html.TR(html.TH(top_div, colspan=f\"{count_col}\")))\n        if self.use_paginate:\n            self.target.parent.append(self.bot_div)\n\n    def current_page(self):\n        return self.page.number\n\n    def get_page(self, page_number):\n        self.page = self.paginator.get_page(page_number)\n        self.target.select_one('tbody').clear()\n        self.target.select_one('tbody') <= self.page\n        self._render_paginate_group()\n\n    def sorted_data(self, event):\n\n        event.preventDefault()\n        target = event.target\n        try:\n            ascending = target.attrs['data-ascending']\n            col_num = int(target.attrs['data-idx'])\n        except KeyError:\n            ascending = 'up'\n            col_num = 0\n        except ValueError:\n            ascending = 'up'\n            col_num = 0\n        \n        def k_str(_item):\n            return _item.children[col_num].text\n        def k_int(_item):\n            return float(_item.children[col_num].text)\n\n        try:\n            self.paginator.object_list.sort(key=k_int)\n        except ValueError:\n            self.paginator.object_list.sort(key=k_str)\n\n        if ascending == 'down':\n            #self.model.reverse()\n            self.paginator.object_list.reverse()\n        self.get_page(1)\n    \n    def update_per_page(self, event):\n        event.preventDefault()\n        selected = [option.text for option in event.target if option.selected]\n        self.per_page = selected[0]\n        rows = self.paginator.object_list\n        self.paginator = Paginator(rows, self.per_page, orphans=self.orphans)\n        self.get_page(1)\n\n    def clear_filter(self, event):\n        event.preventDefault()\n        self.paginator = Paginator(self.model, self.per_page, orphans=self.orphans)\n        self.get_page(1)\n\n    def filter_data(self, event):\n        event.preventDefault()\n        value = event.target.value.lower()\n        if len(value) == 0:\n            self.clear_filter(event)\n        elif len(value) > 0 and len(value) < 2:\n            return\n        new_rows = list(filter(lambda item: value in item.text.lower(), self.model))\n        self.paginator = Paginator(new_rows, self.per_page, orphans=self.orphans)\n        self.get_page(1)\n\n\n# for item in document.select(\".brython-table\"):\n#     BrythonTable(item)\n", ["browser.window", "paginate", "browser.document", "browser.html", "javascript.Date", "browser.aio", "javascript.Math", "browser", "javascript"]], "sys": [".py", "\nfrom _sys import *\nimport javascript\n\n_getframe=Getframe\n\nabiflags=0\n\ndef audit(event,*args):\n ''\n pass\n \nbrython_debug_mode=__BRYTHON__.debug\n\nbase_exec_prefix=__BRYTHON__.brython_path\n\nbase_prefix=__BRYTHON__.brython_path\n\nbuiltin_module_names=__BRYTHON__.builtin_module_names\n\nbyteorder='little'\n\ndont_write_bytecode=True\n\nexec_prefix=__BRYTHON__.brython_path\n\nexecutable=__BRYTHON__.brython_path+'/brython.js'\n\nargv=[__BRYTHON__.script_path]\n\n\ndef displayhook(value):\n if value is not None :\n  stdout.write(repr(value))\n  \ndef exit(i=None ):\n raise SystemExit('')\n \nclass flag_class:\n\n def __init__(self):\n  self.debug=0\n  self.inspect=0\n  self.interactive=0\n  self.optimize=0\n  self.dont_write_bytecode=0\n  self.no_user_site=0\n  self.no_site=0\n  self.ignore_environment=0\n  self.verbose=0\n  self.bytes_warning=0\n  self.quiet=0\n  self.hash_randomization=1\n  \nflags=flag_class()\n\nclass float_info:\n mant_dig=53\n max=javascript.Number.MAX_VALUE\n min=javascript.Number.MIN_VALUE\n radix=2\n \ndef getfilesystemencoding(*args,**kw):\n ''\n\n \n return 'utf-8'\n \ndef getfilesystemencodeerrors():\n return \"utf-8\"\n \ndef getrecursionlimit():\n return 200\n \ndef intern(string):\n return string\n \nclass int_info:\n bits_per_digit=30\n sizeof_digit=4\n \nmaxsize=2 **63 -1\n\nmaxunicode=1114111\n\nplatform=\"brython\"\n\nprefix=__BRYTHON__.brython_path\n\nversion='.'.join(str(x)for x in __BRYTHON__.version_info[:3])\nversion +=\" (default, %s) \\n[Javascript 1.5] on Brython\"\\\n%__BRYTHON__.compiled_date\nhexversion=0x030800f0\n\nclass _version_info:\n\n def __init__(self,version_info):\n  self.version_info=version_info\n  self.major=version_info[0]\n  self.minor=version_info[1]\n  self.micro=version_info[2]\n  self.releaselevel=version_info[3]\n  self.serial=version_info[4]\n  \n def __getitem__(self,index):\n  if isinstance(self.version_info[index],list):\n   return tuple(self.version_info[index])\n  return self.version_info[index]\n  \n def hexversion(self):\n  try :\n   return '0%d0%d0%d'%(self.major,self.minor,self.micro)\n  finally :\n   return '0%d0000'%(self.major)\n   \n def __str__(self):\n  _s=\"sys.version(major=%d, minor=%d, micro=%d, releaselevel='%s', \"\\\n  \"serial=%d)\"\n  return _s %(self.major,self.minor,self.micro,\n  self.releaselevel,self.serial)\n  \n def __eq__(self,other):\n  if isinstance(other,tuple):\n   return (self.major,self.minor,self.micro)==other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __ge__(self,other):\n  if isinstance(other,tuple):\n   return (self.major,self.minor,self.micro)>=other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __gt__(self,other):\n  if isinstance(other,tuple):\n   return (self.major,self.minor,self.micro)>other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __le__(self,other):\n  if isinstance(other,tuple):\n   return (self.major,self.minor,self.micro)<=other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __lt__(self,other):\n  if isinstance(other,tuple):\n   return (self.major,self.minor,self.micro)<other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __ne__(self,other):\n  if isinstance(other,tuple):\n   return (self.major,self.minor,self.micro)!=other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n  \n  \nversion_info=_version_info(__BRYTHON__.version_info)\n\nclass SimpleNamespace:\n\n def __init__(self,/,**kwargs):\n  self.__dict__.update(kwargs)\n  \n def __repr__(self):\n  items=(f\"{k}={v!r}\"for k,v in self.__dict__.items())\n  return \"{}({})\".format(\"namespace\",\", \".join(items))\n  \n def __eq__(self,other):\n  if isinstance(self,SimpleNamespace)and isinstance(other,SimpleNamespace):\n   return self.__dict__ ==other.__dict__\n  return NotImplemented\n  \nSimpleNamespace.__module__=\"types\"\n\nvi=_version_info(__BRYTHON__.implementation)\nimplementation=SimpleNamespace(name=\"brython\",\nversion=vi,\nhexversion=vi.hexversion(),\ncache_tag=None )\n\nclass _hash_info:\n\n def __init__(self):\n  self.width=32\n  self.modulus=2147483647\n  self.inf=314159\n  self.nan=0\n  self.imag=1000003\n  self.algorithm='siphash24'\n  self.hash_bits=64\n  self.seed_bits=128\n  cutoff=0\n  \n def __repr__(self):\n \n  return \"sys.hash_info(width=32, modulus=2147483647, inf=314159, \"\\\n  \"nan=0, imag=1000003, algorithm='siphash24', hash_bits=64, \"\\\n  \"seed_bits=128, cutoff=0)\"\n  \nhash_info=_hash_info()\n\nclass _float_info:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __init__(self):\n  self.dig=15\n  self.epsilon=2 **-52\n  self.mant_dig=53\n  self.max=__BRYTHON__.max_float\n  self.max_exp=2 **10\n  self.max_10_exp=308\n  self.min=2 **(-1022)\n  self.min_exp=-1021\n  self.min_10_exp=-307\n  self.radix=2\n  self.rounds=1\n  self._tuple=(self.max,self.max_exp,self.max_10_exp,self.min,\n  self.min_exp,self.min_10_exp,self.dig,self.mant_dig,self.epsilon,\n  self.radix,self.rounds)\n  \n def __getitem__(self,k):\n  return self._tuple[k]\n  \n def __iter__(self):\n  return iter(self._tuple)\n  \nfloat_info=_float_info()\n\nwarnoptions=[]\n\ndef getfilesystemencoding():\n return 'utf-8'\n \n \n__stdout__=__BRYTHON__.stdout\n__stderr__=__BRYTHON__.stderr\n__stdin__=__BRYTHON__.stdin\n\n__excepthook__=excepthook\n", ["_sys", "javascript"]], "utils": [".py", "from browser import document, window\n\nfrom custom_table import BrythonTable\nfrom custom_select import BrythonSelect\n\n\njq = window.jQuery\nflatpickr = window.flatpickr\nbsCustomFileInput = window.bsCustomFileInput\n\n\ndef init_bsCustomFileInput():\n    bsCustomFileInput.init()\n\n    \ndef init_flatpickr():\n    flatpickr(\".datepicker\", {\n        \"locale\": \"ru\", \n        \"dateFormat\": \"d-m-Y\"\n    })\n\nheaders={'X-Requested-With':'X-Requested-With'}\n\n\ndef show_toast(message=\"\"):\n    document['toast-body'].html = message\n    jq('#mainToast').toast('show')\n\ndef show_modal():\n    jq('#modalEdit').modal('show')\n\ndef hide_modal():\n    jq('#modalEdit').modal('hide')\n\ndef form_serialize(form):\n    s_ser = ''\n    for el in form.elements:\n        id = el.name if el.name else el.id\n        if id:\n            if el.type == 'select-multiple':\n                sel_options = [item for item in el.options if item.selected]\n                for item in sel_options:\n                    s_ser += f'{id}={item.value}&'\n            elif el.type == 'checkbox':\n                if el.checked:\n                    s_ser += f'{id}=checked&'\n            elif el.type == 'radio':\n                if el.checked:\n                    s_ser += f'{id}={el.value}&'\n            elif el.type == 'button' or el.type == 'submit':\n                pass\n            else:\n                s_ser += f'{id}={el.value}&'\n    return s_ser\n\ndef clear_form(form):\n    for el in form.elements:\n        if el.type == 'text' or el.type=='textarea':\n            el.value = \"\"\n        elif el.type == 'radio' or el.type == 'checkbox':\n            el.checked = False\n        elif el.type == 'select-one' or el.type == 'select-multiple':\n            el.value = \"All\"\n\ndef get_spinner(message=\"\"):\n    return '<span class=\"spinner-border spinner-border-sm\" role=\"status\" aria-hidden=\"true\"></span>'+message\n\ndef get_big_spinner():\n    return \"\"\"<div class=\"d-flex justify-content-center\"><div class=\"spinner-border\" style=\"width: 5rem; height: 5rem;\" role=\"status\"><span class=\"sr-only\">Loading...</span></div></div>\"\"\"\n\n\ndef clear_errors():\n    for elem in document.select('.non-valid'):\n        elem.text = \"\"\n\n\ndef show_errors(errors={}, validate=False, message=\"\"):\n    if validate:\n        for key, value in errors:\n            document.select_one(f\"#{key}_error\").text = value\n\n        show_toast(message)\n    else:\n        show_toast(message+\"\\n\"+errors)\n\ndef get_id_trow(event):\n    \"\"\"\u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 id \u0437\u0430\u043f\u0438\u0441\u0438 \u0432 \u0411\u0414 \u043f\u0440\u0438 \u043a\u043b\u0438\u043a\u0435 \u043f\u043e \u0441\u0442\u0440\u043e\u043a\u0435 \u0442\u0430\u0431\u043b\u0438\u0446\u044b\n    event - \u0441\u043e\u0431\u044b\u0442\u0438\u0435 \u0449\u0435\u043b\u0447\u043a\u0430\n    \"\"\"\n    tr = event.target.closest(\"TR\")\n    try:\n        id = tr.attrs[\"id\"]\n    except KeyError:\n        id = 0\n    return id\n", ["browser.window", "custom_table.BrythonTable", "custom_select.BrythonSelect", "browser.document", "custom_table", "custom_select", "browser"]], "browser.aio": [".py", "from _aio import *\nfrom browser import window\n\n\ndef _task(coro,Id,block):\n async def _task():\n  block[Id]=None\n  try :\n   block[Id]=await coro\n  except Exception as e:\n   block[Id]=e\n   \n  if not block[Id]:\n   del block[Id]\n return _task()\n \n \nasync def gather(*coros,rate=0):\n dones={}\n counts=0\n for c in coros:\n  run(_task(c,f'task{counts}',dones))\n  counts +=1\n while not all(dones.values()):\n  await sleep(rate)\n return dones\n \n \nclass Future:\n ''\n\n\n \n \n def __new__(cls,*args,**kwargs):\n  methods={}\n  def executor(resolve_cb,reject_cb):\n   methods[\"resolve\"]=resolve_cb\n   methods[\"reject\"]=reject_cb\n  promise=window.Promise.new(executor)\n  promise._methods=methods\n  promise.set_result=cls.set_result.__get__(promise)\n  promise.set_exception=cls.set_exception.__get__(promise)\n  return promise\n  \n def set_result(self,value):\n  self._methods[\"resolve\"](value)\n  \n def set_exception(self,exc):\n  self._methods[\"reject\"](exc)\n", ["browser.window", "browser", "_aio"]], "custom_select": [".py", "from browser import document, html, window\n\n\nclass BrythonSelect():\n\n    default_value_trigger = \"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0438\u0437 \u0441\u043f\u0438\u0441\u043a\u0430\"\n\n    def __init__(self, target, live_search=True, max_options=4):\n        self.target = target\n        self.initUIComponent()\n        self.render_target()\n        self.live_search = live_search\n        self.max_options = max_options\n        self.selectedIndex = self.target.selectedIndex\n        self.multiselectable = self.target.multiple\n        self.update_tigger()\n        self.render()\n        self.register_events()\n        \n    def initUIComponent(self):\n        self.main_div = html.DIV(Class=\"select sm\")\n        self.dropdown = html.DIV(html.DIV(Class=\"dropdown__inner\"), Class='select__dropdown')\n        self.trigger = html.BUTTON(html.DIV(self.default_value_trigger, Class='trigger_inner'), \n            Class='btn select__trigger', **{'data-select': 'trigger'})\n        self.listbox = html.UL(Class=\"select__items\")\n        self.search = html.INPUT(Class='form-control', type=\"search\")\n        self.backdrop = html.DIV(Class='select__backdrop', **{'data-select': 'backdrop'})\n        \n    def _cut_text_trigger(self, text):\n        pass\n\n    def update_tigger(self):\n        text = \"\"\n        sel_options = [item for item in self.target.options if item.selected]\n        if len(sel_options) > self.max_options:\n            text = f\"\u0412\u044b\u0431\u0440\u0430\u043d\u043e {len(sel_options)} \u043f\u043e\u0437\u0438\u0446\u0438\u0439\"\n        else:\n            for item in sel_options:\n                if text:\n                    text += \"; \" + item.text\n                else:\n                    text = item.text\n        if text:\n            self.trigger.select_one(\".trigger_inner\").text = text\n            self.trigger.select_one(\".trigger_inner\").attrs[\"title\"] = text\n        else:\n            self.trigger.select_one(\".trigger_inner\").text = self.default_value_trigger\n\n    def register_events(self):\n\n        self.trigger.bind('click', self.toogle)\n        self.listbox.bind('click', self.change_value)\n        self.backdrop.bind('click', self.toogle)\n        self.search.bind('input', self.apply_filter)\n    \n    def render_target(self):\n        self.target.parent.insertBefore(self.main_div, self.target)\n        self.main_div.prepend(self.target)\n        self.target.style = {\"opacity\": 0, \"position\": \"absolute\"}\n        self.target.width = 31\n    \n    def render(self):\n        self.dropdown.prepend(html.DIV(self.search, Class='search'))\n        self.dropdown.select_one(\".dropdown__inner\").append(self.listbox)\n        self.main_div <= self.backdrop\n        self.main_div <= self.trigger\n        self.main_div <= self.dropdown\n        \n    def apply_filter(self, event):\n        event.preventDefault()\n        str_search = event.target.value\n        self.listbox.html = self._get_listbox(str_search)\n\n    def change_value(self, event):\n        item = event.target\n        self.set_value_item(item)\n        self.update_tigger()\n        if not self.multiselectable:\n            self.hide_listbox()\n\n    def set_value_item(self, item):\n        index = item.attrs.get(\"data-select\")\n        if self.multiselectable:\n            if item.classList.contains(\"select__item_selected\"):\n                item.classList.remove(\"select__item_selected\")\n                self.target.options[index].selected = False\n                \n            else:\n                item.classList.add(\"select__item_selected\")\n                self.target.options[index].selected = True\n        else:\n            for prev_item in self.listbox.select(\".select__item_selected\"):\n                prev_item.classList.remove(\"select__item_selected\")\n                \n            item.classList.add(\"select__item_selected\")\n            item.attrs[\"aria-selected\"] = \"true\"\n            self.target.options[index].selected = True\n        \n    \n    def _is_show(self):\n        if self.main_div.classList.contains(\"select_show\"):\n            return True\n        else:\n            return False\n    \n    def toogle(self, event):\n        event.preventDefault()\n        if self._is_show():\n            self.hide_listbox()\n        else:\n            self.show_listbox()\n    \n    def _get_height(self, elt, height=0):\n        if elt.height == \"auto\":\n            return self._get_height(elt.parent)\n        else:\n            return elt.height\n        \n    def _get_dropdown_style(self):\n\n        el_height = self._get_height(self.dropdown)\n        search_height = self._get_height(self.search)\n        padding = 10\n\n        li_height = len(self.listbox.children) * el_height\n        to_bot = window.innerHeight - self.dropdown.scrolled_top - el_height\n        if self.dropdown.scrolled_top < to_bot:\n            top = el_height - 3\n            max_height = to_bot - padding\n        else:\n            top = -(self.dropdown.scrolled_top - padding)\n            max_height = top * -1\n        max_height_listbox = max_height - search_height\n        dropdown_style = {\"max-height\": f\"{max_height}px\",\n            \"overflow\": \"hidden\",\n            \"min-height\": \"162px\",\n            \"position\": \"absolute\",\n            \"transform\": f\"translate3d(0px, {top}px, 0px)\",\n            \"top\": \"1px\",\n            \"left\": \"0px\",\n            \"will-change\": \"transform\"\n                          }\n        listbox_style = {\"max-height\": f\"{max_height_listbox}px\",\n            \"overflowY\": \"auto\",\n            \"min-height\": \"98px\"\n                         }\n        return dropdown_style, listbox_style\n\n    def show_listbox(self):\n        if self.listbox.html == \"\":\n            self.listbox.html = self._get_listbox()\n        self.dropdown.style, self.listbox.style = self._get_dropdown_style()\n        self.main_div.classList.add(\"select_show\")\n        self.dropdown.classList.add(\"select_show\")\n        try:\n            self.listbox.select('.select__item_selected')[0].focus(preventScroll=False)\n        except IndexError:\n            pass\n\n    def hide_listbox(self):\n        self.dropdown.classList.remove(\"select_show\")\n        self.main_div.classList.remove(\"select_show\")\n        self.search.value = \"\"\n        self.listbox.html = self._get_listbox()\n\n    \n    def _get_listbox(self, str_filter=\"\"):\n        li = ''\n        for item in self.target.options:\n            if str_filter.lower() in item.text.lower():\n                li += '<li class=\"select__item'\n                if item.selected:\n                    li += ' select__item_selected\"' \n                else:\n                    li += '\"'\n                li += f' data-select=\"{item.index}\" tabindex=\"0\">{item.text}</li>'\n        return li\n\n    def refresh(self):\n        self.listbox.html = \"\"\n\n\n# for select_item in document.select(\".brython-select\"):\n#     BrythonSelect(select_item)\n", ["browser.html", "browser.window", "browser.document", "browser"]]}
__BRYTHON__.update_VFS(scripts)